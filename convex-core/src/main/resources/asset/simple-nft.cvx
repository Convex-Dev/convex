;;
;;
;; Simple NFT library
;;
;; Enables the creation of minimal NFT tokens.
;; 
;; The NFT is just a long. User can build a layer on top so that this number points to any arbitrary data.
;;
;;


;; REGISTERING THE LIBRARY


(call *registry*
      (cns-update 'asset.simple-nft
                  *address*))


(call *registry*
      (register {:name "Simple NFT Library"}))


;; VALUES


(def counter
 
  ^{:doc {:description ""}}

  0)



(def offers

  ^{:doc {:description "Map of `owner` -> map of `recipient-address` -> `id-set`"}}

  {})



(def self

  *address*)


;; IMPLEMENTING `convex.asset` INTERFACE


(defn balance

  ^{:callable? true}

  [owner]

  (or (get-holding owner)
      #{}))



(defn offer

  ^{:callable? true}

  [receiver quantity]

  (let [caller-offers (get offers
                           *caller*
                           {})]
    (def offers
         (assoc offers
                *caller*
                (assoc caller-offers
                       receiver
                       quantity)))))



(defn owns?

  [owner nfts]

  (subset? nfts
           (get-holding owner)))



(def quantity-add

  ^{:callable? true}

  union)



(def quantity-sub

  ^{:callable? true}

  difference)



(def quantity-subset?

  ^{:callable? true}

  subset?)



(let [internal-direct-transfer (fn [sender receiver quantity]
                                 (let [receiver             (address receiver)
                                       sender-balance       (or (get-holding sender)
                                                                #{})
                                       _                    (assert (subset? quantity
                                                                             sender-balance))
                                       receiver-balance     (or (get-holding receiver)
                                                                #{})
                                       new-sender-balance   (difference sender-balance
                                                                        quantity)
                                       new-receiver-balance (union receiver-balance
                                                                   quantity)]
                                   (set-holding sender
                                                new-sender-balance)
                                   (set-holding receiver
                                                new-receiver-balance))
                                   quantity)]

  (defn accept

    ^{:callable? true}

    [sender quantity]

    (let [sender           (address sender)
          sender-offers    (or (get offers
                                    sender)
                               {})
          offer            (or (get-in offers
                                       [sender
                                        *caller*])
                               #{})
          _                (assert (subset? quantity
                                            offer))
          receiver-balance (or (get-holding *caller*)
                               #{})
          new-offer        (difference offer
                                       quantity)]

      (def offers
         (assoc offers
                sender
                (assoc sender-offers
                       *caller*
                       new-offer)))

      (internal-direct-transfer sender
                              *caller*
                              quantity)))


  (defn direct-transfer

    ^{:callable? true}

    [receiver quantity]

    (internal-direct-transfer *caller*
                              receiver
                              quantity)))




;; ACTOR SPECIFIC CALLABLE FUNCTIONS


(defn burn

  ^{:callable? true
    :doc       {:description "Destroys a set of NFTs. NFTs must be owned by the caller."}}

  [nft-set]

  (let [owned-nfts (get-holding *caller*)
        nft-set    (cond
                     (long? nft-set) #{nft-set}
                     (set? nft-set)  nft-set
                     :else           (set nft-set))]
    (when-not (subset? nft-set
                       owned-nfts)
      (fail :TRUST
            "Trying to burn nfts which are not owned!"))
    (set-holding *caller*
                 (difference owned-nfts
                             nft-set))
    nft-set))



(defn create 

  ^{:doc {:description "Library function to create a NFT. Metadata for the NFT is option, will be nil if not specifies."}}

  []

  (call self
        (create-nft)))



(defn create-nft

  ^{:callable? true
    :doc       {:description "Contract to create a new NFT, with a fresh ID and arbitrary metadata."}}

  []

  (let [id         counter
        owner      *caller*
        owned-nfts (or (get-holding owner)
                       #{})]
    (set-holding owner
                 (conj owned-nfts
                       id))
    (def counter
         (inc counter))
    id))
